안녕하세요 저는 오늘 솔라나에 대해 발표하도록 하겠습니다. 
우선 블록체인을 공부하고 계시는 여러분들은 블록체인 트릴레마에 대해서 다들 들어보신 적이 있으실겁니다. 블록체인 트릴레마란 블록체인의 성능을 아무리 좋게 만들어도 세 가지 특성이 공존하기 어렵다는 얘기입니다. 한가지는 decentralization 탈중앙성이고, 또 한가지는 scalbility 확장성이고, 마지막 한 가지는 security 보안입니다. 현재 비트코인, 이더리움 같은 경우는 수많은 노드와 컴퓨터들을 운영하고, 비트코인은 pow방식, 이더리움은 pos방식으로 높은 탈중앙성과 높은 보안성을 유지하고 있습니다. 하지만, 비트코인과 이더리움의 한계로 여겨지는 것이 트랜잭션 속도 즉 tps인데, 이거는 이제 확장성에 속합니다. 즉, 블록체인 트릴레마는 남은 두 가지를 이루더라도 나머지 한개는 이룰 수가 없이, 세가지는 동시에 이룰 수가 없다는 것을 말합니다. 오늘 발표할 솔라나는 트랜잭션 속도에서 월등히 성장했지만, 이와 동시에 탈중앙성은 다소 잃게되었습니다. 
이 슬라이드는 2024.5.15 기준으로 체인들의 tps 순위를 매겨놓은 것인데, 뭐 보시다시피 솔라나가 빠르고, sui가 그다음을 잇고 있습니다. bsc, 폴리곤, 톤, 트론 빠른 축에 속합니다. 이에 반대로 이더리움, 비트코인 상당히 느린 tps를 보여줍니다. 
그래서 오늘 발표할 내용은, 솔라나가 어떤 원리로 이렇게 트랜잭션 속도가 빠른 체인을 만들 수 있었는지 그 원리를 설명해드리려고 합니다. 크게는 이렇게 6step으로 되어있습니다. user -> gulf stream -> block building -> trubine -> block verification -> consensus이렇게 6가지 스텝에 대해서 설명 드리겠습니다. 
지난주에 준원님께서 이더리움에 대해서 발표해주셨는데, 이더리움과 솔라나의 차이를 기반으로 발표하도록 하겠습니다. 
자 그래서 user structure면에서 솔라나는 어떤 특징이 있냐? 솔라나와 이더리움은 기본적으로 암호화할때  다른 타원곡선을 쓴다든가 그런 것도 있지만, 트랜잭션의 구성요소 자체가 다릅니다. 솔라나의 트랜잭션 안에는 다른 체인과는 다르게, 트랜잭션 안에 트랜잭션과 상호작용하게되는 모든 account들이 전부 다 들어가있습니다. 모든게 어카운트다. 뭐 데이터도 유저도 프로그램도 다 어카운트라고 표현을 합니다. 컨트랙트를 짤때, 그니까 트랜잭션을 만들때, 분명 그 트랜잭션과 상호작용하는 여러가지 account들이 있을텐데, 이거를 처음부터 다 박아놨다. 그 트랜잭션이 읽거나 쓰는 instruction에서 상호작용하는 account들이 account addresses로 list형식으로 이미 다 들어가 있는 거고, 그 account마다에 해당하는 instruction이 전부 다 하나의 transaction message에 들어가있고, user structure는 그 트랜잭션 메세지와 서명이 같이 들어가 있습니다. 
그 다음 스텝은 뭐냐면 gulf stream이라는 건데, 이더리움에서는, 모든 노드가 똑같은 구조를 가지고 있습니다. 그런데, 어떤 노드는 validator의 역할을 하고, 어떤 노드는 rpc 노드의 역할을 하고, 어떤 노드는 block proposer의 역할을 하고 다 구성요소는 같지만, 행하는 일이 다를 뿐입니다. 하지만 솔라나에서는 rpc 노드와 validator노드가 구분되어있습니다. 
그래서 이더리움에서의 트랜잭션 전파가 어떻게 이뤄졌었는지를 다시 떠올려보면, 트랜잭션이 생성되고, 개인키로 서명이 완료되고, 유효성 검사까지 받으면 트랜잭션은 전파되어야합니다. 근데 이 트랜잭션이 전파될때, 이더리움에서는 어떤 과정으로 전파되냐, 가장 가까운 노드로 보내지고, 그 노드가 트랜잭션의 유효성을 검증하고, 검증되면, 다른 노드로 보내고 이런과정을 계속 반복하게 되잖아요. 근데 이더리움에서는 이럴때 트랜잭션을 멤풀에 보관을 해요. 지금 트랜잭션을 전파하고, 블록에 포함되기 이전에는 멤풀에 잠시 트랜잭션을 대기시키면서 다른 트랜잭션을 받거나, 전파하거나 이 과정을 계속 반복합니다. 그런식으로 여러 노드들이 계속 트랜잭션을 전파 받고, 전파 하는 것을 반복하면서 트랜잭션을 서로 공유하고 동기화를 하게됩니다. 그러다가, 블록을 제안하게되는 랜덤으로 결정된 proposer node가 검증된 트랜잭션들을 모아서 블록을 생성하게 되는 것입니다. 그리고 여기서 pos에 따라 예치한 금액이 많을 수록 proposer가 될 확률이 높아지는 것입니다. 
이더리움에 대한 설명이 길었는데, 그래서 솔라나랑 이더리움의 차이가 뭐냐? 여기 보시면 gossip network + 멤풀 이라고 되어있습니다. 그런데, 솔라나에는 멤풀이 없습니다. 이더리움에서 멤풀이 존재해야되는 이유가 뭐냐면, 결국에는 트랜잭션이 모든 노드들 사이에서 p2p로 전파되면서 동기화되는 과정을 거치다가, 랜덤으로 선정된 proposer가 자신의 멤풀에서 트랜잭션을 선택해서 유효성을 검증하고, 얘네들을 모아서 블록을 생성하는 겁니다. 그런데 솔라나는 블록을 생성하기 이전에, 새로 생긴 트랜잭션들을 모든 노드에 동기화할 필요성이 없이, 하나의 leader 노드에 새로 생긴 트랜잭션들을 모두 몰아주고, 그 leader 블록이 새로운 블록을 만들게되는 겁니다. 그래서 이 블록이 만들어지면, 그 블록을 다른 노드들에 전파만 하면 되는 겁니다. 
그래서 솔라나는 어떤 과정을 거치냐면, 이 다음 슬라이드에 보시면 솔라나는 stake-weighted quality of service라는 시스템을 사용합니다. user에서 트랜잭션을 이렇게 rpc 노드들을 거쳐서 validator 노드들에게 보내게됩니다. 솔라나에서 rpc노드들은 그냥 거쳐가는 길 역할만해주고, validator들은 무조건 staking이 된 애들만 validator가 됩니다. 그런데 여기서 validator에 staking이 많이 되어있을수록, 리더가 그 validator에서 보낸 트랜잭션들을 우선처리하는 메커니즘이 있습니다. 이게 짭 validator를 피하기 위한 수단인겁니다. 
그래서 정리하자면, 솔라나는 staking이 된 validator 노드들만 consensus에 참여할 수 있는 권한을 얻는데, 일정 시간에 한번씩 leader노드가 정해지게 됩니다. 노드는 이제 모드 전환을 하는데, validator노드들은 leader mode란게 있어서, leader로 선정이되면, 그 직전에 트랜잭션을 받는 행위를 다 멈추고, 블록을 만들 준비를 하게 됩니다. 그래서 한번에 많은 트랜잭션을 받고, 거기서 블록을 만듭니다. 
이제 여기까지 gulf stream을 통해 더 빠르게 블록을 만들 수 있었는데, 이제 블록을 전파를 해야됩니다. 이더리움에서도 블록을 만들면 네트워크에 broadcasting을 해야하잖아요? 여기서는 그것도 이더리움보다 빨리합니다. 이더리움에서는 블록이 완전히 생성이 되어야 전파를 시작할 수가 있는데, 솔라나에서는 블록이 완전히 생성이 안되어도, 전파를 할 수가 있습니다 ("?)
이 tpu는 블록을 만드는 과정입니다. 그러니까 이전까지는 트랜잭션을 리더가 다 받는다. 까지 한건데, 여기는 블록을 만드는겁니다. 이 tpu라는 거는 validator 노드 리더노드 안에 들어있는건데, 이 과정에서 fetch랑 verify는 그냥 넘어가고, banking stage가 있습니다. banking stage에서는 하나의 entry안에 64개의 transaction을 받습니다. 이 64개의 트랜잭션을 병렬처리를 합니다. 원래는 모든 트랜잭션을 다 순차적으로 처리해야하는데, 이게 어떻게 가능하냐..? 앞으로 돌아가서, user structure를 보면 가장 중요한 차이점이 뭐였죠? account  address들이 트랜잭션에 다 들어있었죠? 그래서 이 64개의 transaction을 묶을 때, 이 의존성을 고려해서 서로 의존성이 없는 트랜잭션을 64개를 묶어서 처리하게 됩니다. 그래서 병렬처리가 가능한겁니다. 
이제 그 다음은 poh입니다. 이거는 그 사실 pow pos이런거는 합의알고리즘의 일종이잖아요? 하지만 이거는 사실 합의 알고리즘은 아니고, 그냥 별게 없습니다. PoH는 Proof of History로 pow나 pos처럼 consensus의 일종은 아니다. PoH는 사실상 자료구조의 일종으로, 시간 순서를 나타내기 위해 쓰인다. 솔라나에서는 PoH를 솔라나만의 "상대적 시계"로 사용한다. SHA256이라는 해쉬함수를 활용하여, 연속적인 해싱을 한다. 예를들어, 이전에 생성된 Hash1을 다시 hash함수에 넣어서 hash(hash1) = hash2 이런식으로 만든다. 이때 transaction data와 이전 해시를 같이 넣는다. SHA256 해시함수에는 deterministic -> 동일한 입력은 동일한 해시, 고정크기, 빠르게 계산, 원상복구 불가(역연산 불가), avalanche effect(하나라도 바뀌면 다 바뀜) 다 달라짐. 동일한 출력이 나오는 다른 입력은 불가능에 가까움
그다음은 이제 turbine입니다. 이제 블록 생성을 완료했으니, 이제 broadcasting 전파를 해야됩니다. turbine은 전파 방법입니다. banking stage가 끝났습니다. leader node가 블록을 만들었고, 이제 전파를 하면되는데, 전파도 효율적으로 하고싶다고 합니다. 블록을 64개로 또 쪼개는데. 그걸 또 shred라는 단위라고 나타내고 32개의 data shred와 32개의 recovery shred로 만들어서 절반가까이 소실되더라도, 복구할 수 있게끔 블록을 작은 단위로 쪼개서 이제 보냅니다. 근데 이렇게 쪼개는게 중요한게 아니라, 여기서 머클트리 형식으로 보냅니다. 걍 트리형식으로 보낸다고 생각하시면됩니다. 원래 리더가 블록을 만들면 얘가 모든 노드에 새로운 블록이 생성되었다. 이걸 모두에게 전파하려면 그 노드에 통신 overhead가 발생할 수 있기 때문에 그걸 덜어주는 겁니다. 그니까 제가 혼자서 햄버거 100개를 백명한테 나눠주긴 힘드니까 제가 세명한테 주면 그 세명이 또 친구 세명한테 주고, 뭐 그걸 반복한단 얘깁니다. 
이제 block verfication 이랑 consensus가 남았습니다. validator 가 turbine을 통해 새로운 블록을 수신하게 되면, validator는 블록의 모든 트랜잭션을 검증해야한다. 이때 모든 트랜잭션을 replay하게 되는데, 이것이 POH로 인해 가능해진다. POH hash는 병렬로 검증한다. 여기 step을 보면, shred fetch stage가 있다. turbine에서 shred 단위로 전송하기 때문에, 그걸 fetch한다. sig verify stage에서는 shred가 leader의 서명을 가지고 있는지 검증한다. retransmit stage에서는 upstream validator가 적절한 downstream validator로 shred들을 넘긴다. (터빈의 트리 구조로) replay에서는 검증자가 각 트랜잭션을 정확히 올바른 순서대로 재생성하여 local bank의 상태를 업데이트 한다. replay stage는 tpu의 banking stage와 유사하며, 가장 중요한 단계이다. 여기가 블록을 검증하여 새로 추가하는 것이다.
솔라나는 Tower BFT라는 합의 알고리즘을 사용한다. 이는 전통적인 합의 알고리즘과는 다르게 POH를 사용하여 위에서 말했던 것처럼 트랜잭션의 순서를 미리 정해놓는다. 미리 정해놓기 때문에 트랜잭션의 순서를 파악하기 위해 노드 간 통신이 필요하지 않다. 그리고 이렇게 블록들이 전파되었을 때, 이더리움과 마찬가지로 블록의 유효성을 검증하는 투표를 하게 된다. 합의에 참여하려면 validator들은 유효한 블록에 대해 투표를 제출한다. 이것은 트랜잭션으로 처리되며, 일반 사용자 트랜잭션과 함께 블록에 포함된다. 이러한 이유로 solana 트랜잭션은 투표 트랜잭션과 비투표 트랜잭션으로 구분된다. 성공적인 투표를 제출하면, 크레딧을 얻게된다. 솔라나:poh로 이놈이 보낸 순서가 맞다는 그냥 믿음 +  순서가 보장되니 의존관계 없는거는 동시에 병렬로 돌려버린다음에  머클루트 확인 / 이더리움: 블록에 있는 순서 자체도 믿을 수 없으므로 하나씩 돌려본 다음에 머클루트 최종 확인.
솔라나에서는 새로 생성된 블록에 대해 모든 검증자가 합의할 때가지 기다리지 않고 다음 블록을 생성한다. (continous block generation) solana는 각 블록에 대해 bank를 사용하여 해당 블록의 상태를 참조한다. 
solana에서 tx의 상태는 합의과정에서 어떤 상태에 있는지에 따라 달라진다. processed는 처리된 상태, confirmed는 확인된 상태(2/3에 의해 투표, 트랜잭션이 포함된 블록이), 그리고 finalized(트랜잭션이 포함된 블록 위에 31개이상의 블록이 쌓임) 
confirmed된 블록이 finalized되지 않은 상태는 지금껏  없다. 