블록체인에는 3가지 공생 불가능한 한계점이 있는데, 이를 blockchain trillema라고 한다. 탈중앙화, 확장성, 보안 이 세 가지 요소 중에서, 2가지는 만족시킬 수 있지만, 나머지 한 가지는 만족시키지 못한다는 뜻이다. 비트코인과 이더리움은 탈중앙화와 보안성 문제를 해결하였지만, 확장성 문제를 겪고 있다. 이를 해결하기 위해서 여러가지 시도들이 이뤄지고 있다. 

이 중에서도 솔라나는 tps가 빠른 것으로 유명하다. 이번 발표에서는 Solana의 구조를 알아보도록 하겠다.
솔라나는 tps를 최대한 빠르게, 그리고 transaction fee를 최대한 적게 하기 위해 만들어졌다. Solana는 6개의 구조로 이루어져있다. 

우선 Users에는 크게 중요한 점은 없지만, 지난 시간에 준원님이 발표하셨던 이더리움과 비교를 해보자면, 솔라나와 이더리움은 다른 타원 곡선을 쓴다. 그리고 트랜잭션의 구성요소 또한 다르다. 뭐 어쩌고저쩌고
솔라나 트랜잭션 구성요소에는 account addresses가 있는데, 여기에는 해당 트랜잭션이 작동할 때, 읽거나 쓰는 모든 account들이 list로 들어가있다. -> 호환성이 안좋게 만든다. 그리고 header에는 account address list의 reference들이 전부 들어가 있다. 그리고 instruction에는 트랜잭션이 행하는 모든 operation이 들어가 있다. 

Gulf stream
우선 RPC 노드란 블록체인 네트워크와 상호작용하기 위한 서버 혹은 노드를 의미한다. RPC 노드는 개발자가 블록체인 네트워크에 연결하고 데이터를 읽거나 트랜잭션을 전송하도록 도와준다. 일반적으로 일반 사용자가 풀노드를 운영할 수는 없기 때문에, rpc 노드를 통해 네트워크 데이터에 접근한다든가, 트랜잭션을 전송한다든가, api 요청을 처리할 수 있다. 
검증자 노드는 일정량의 코인을 스테이킹함으로써 consensus에 참여할 자격을 얻는다. 이와 달리 솔라나에서 rpc 노드는 네트워크에 코인을 스테이킹하지 않는다. 그러므로 rpc노드는 consensus에 참여할 자격이 없다. 
이더리움에서는 모두 같은 소프트웨어 실행할 수 있지만(같은 설정을 가지지만), rpc노드와 validator노드의 역할이 다른데, 솔라나에서는 두 개의 노드가 완전히 분리되어있고 소프트웨어 구조 자체가 다르다. 
솔라나는 멤풀이 없다. 일반적으로 다른 블록체인에서는 트랜잭션이 가십 프로토콜을 통해 네트워크에 p2p로 무작위로 전파된다. 하지만 솔라나에서는 전파 과정 없이 leader slot 개념을 이용해 각 슬롯에서 리더 노드가 트랜잭션을 직접 처리한다. 무슨 말이냐면, 리더라는 검증자를 미리 정해놓고(이게 이더리움에서는 proposer node) 트랜잭션을 전파 과정 없이 직접 leader node에게 보낸다.
리더는 계속 바뀌는데, 매 에포크(약 2일)이전에 생성이 된다. 각 슬롯에 리더가 선정되는데, 1슬롯은 400밀리초이다. 여기서 더 많은 지분을 가질수록 리더로 선정될 확률이 높아진다. 각 슬롯동안 트랜잭션은 리더에게 전달되고 리더는 블록을 생성할 기회를 갖는다. 검증자가 리더로 활동할 차례가 되면, 일반적 검증자에서 "리더 모드"로 전환하여 트랜잭션을 처리하게 되고 이를 브로드캐스트한다.
솔라나는 2024년부터 "Stake-Weighted Quality of Service" (SWQoS) 라는 것을 사용하는데, 스팸 방지와 sybil 공격 저항을 강화하기 위해 도입하였다. 리더가 트랜잭션을 처리할때, 스테이킹이 많은 노드가 보낸 트랜잭션일 수록 트랜잭션 메시지를 우선 처리하도록 하는 메커니즘을 추가하였다.
솔라나에서는 이런 방식으로 리더가 트랜잭션을 한 번에 처리한다. 일반적인 블록체인 네트워크에서는 블록을 완전히 생성한 뒤에 이를 전파한다. 하지만 솔라나에서는 연속 블록 생성 방식을 사용하여, 할당된 시간 슬롯동안 블록을 생성하면서 실시간으로 스트리밍한다. 
-> 이게 뭔소리냐? 파이프라이닝을 생각하면 된다. 솔라나에서는 블록 생성 과정을 조각으로 쪼개서 latency를 줄인다. 한 슬롯은 400밀리초이다. 리더는 4슬롯을 할당받는다. 다음 리더로 넘어가기 이전에, 다음 리더로 예정된 검증자 노드는 트랜잭션을 받는 것을 멈춘다. 리더로 선정되고 트랜잭션을 받기 시작하면, 트랜잭션 메시지들은 리더 노드의 TPU로 들어가게 된다. 이때 TPU는 transaction processing unit이다. tpu는 몇 가지 스테이지로 구성되어있는데, fetch stage -> sig verify stage -> banking stage -> broadcast stage로 구성되어있다. fetch는 트랜잭션을 가져오는거고, sig verify stage는 트랜잭션이 합당한지를 검사하는 거다. 
banking stage가 중요하다. 솔라나에서는 트랜잭션을 병렬처리 하기 위해서, 트랜잭션 64개를 묶어서 batch로 하나의 엔트리로 만든다. 그리고 하나의 엔트리를 동시에 처리한다. 즉, 64개의 트랜잭션을 병렬 처리한다는 얘기다. 이게 가능한 이유는, 솔라나의 트랜잭션에는 account addresses가 있기 때문이다. 솔라나가 batch를 설정할 때, account address를 확인하고, 서로 의존성이 있는 트랜잭션들은 서로 다른 엔트리로 가게된다. 그래서 엔트리에 있는 트랜잭션 끼리는 병렬로 실행돼서 처리가 빨라지게 되는 것이다. 
PoH는 Proof of History로 pow나 pos처럼 consensus의 일종은 아니다. PoH는 사실상 자료구조의 일종으로, 시간 순서를 나타내기 위해 쓰인다. 솔라나에서는 PoH를 솔라나만의 "상대적 시계"로 사용한다. SHA256이라는 해쉬함수를 활용하여, 연속적인 해싱을 한다. 예를들어, 이전에 생성된 Hash1을 다시 hash함수에 넣어서 hash(hash1) = hash2 이런식으로 만든다. 이때 transaction data와 이전 해시를 같이 넣는다. 
그래서 이 hash chain은 hash에 대한 상대적인 타임스탬프를 제공하여 트랜잭션의 순서가 결정되게 된다. 그리고 그 타임스탬프 count를 이용하여 순서를 비교할 수 있다. 해시값은 이전 해시와 트랜잭션 데이터에 의존하게 되므로 타임스탬프로서 작동할 수 있다. 
그리고 이는 최종적으로 PoH의 핵심 이점은 리더 스케줄(leader schedule)이 올바르게 준수되도록 보장한다는 점입니다. 이 말은 특정 검증자(validator)가 블록을 생성할 차례가 아닌 상황에서 블록을 미리 생성하거나 제출하는 것을 방지한다는 뜻입니다. 그니까 그 순서를 보장해준다는 말이다.
turbine은 블록 생성 이후 다른 노드들에게 블록을 효율적이고 빠르게 전파하기 위한 과정이다. banking stage가 끝나면, 생성된 블록을 네트워크에 전파해야한다. turbine은 블록 데이터를 작은 데이터 조각인 "shreds"로 나눈다. 이때 FEC BATCH라는 것으로 shreds가 묶이는데, 32개의 data shreds와 32개의 recovery shreds로 구성된 64개의 shreds로 구성된다. 그니까 걍 예비 shreds다. 그리고 이 배치 형태로 전파를 하는데, 64개의 shred를 머클 트리 형태로 보낸다. 머클 트리 형태로 전파를 하는 이유는 블록을 생성한 리더 노드가 다른 모든 노드에게 블록 전파를 하게 되면 통신 overhead가 발생할 수 있기 때문이다. 그래서 한 노드가 모든 노드로 블록을 전파하는 것이 아니라, 트리 구조로 전파시켜서 대규모 데이터를 효율적으로 처리할 수 있도록 한다.
블록이 전부 다 전파된 후에는, block verification 과 consensus를 거쳐야한다. 
validator 가 turbine을 통해 새로운 블록을 수신하게 되면, validator는 블록의 모든 트랜잭션을 검증해야한다. 이때 모든 트랜잭션을 replay하게 되는데, 이것이 POH로 인해 가능해진다. POH hash는 병렬로 검증한다. 여기 step을 보면, shred fetch stage가 있다. turbine에서 shred 단위로 전송하기 때문에, 그걸 fetch한다. sig verify stage에서는 shred가 leader의 서명을 가지고 있는지 검증한다. retransmit stage에서는 upstream validator가 적절한 downstream validator로 shred들을 넘긴다. (터빈의 트리 구조로) replay에서는 검증자가 각 트랜잭션을 정확히 올바른 순서대로 재생성하여 local bank의 상태를 업데이트 한다. replay stage는 tpu의 banking stage와 유사하며, 가장 중요한 단계이다. 여기가 블록을 검증하여 새로 추가하는 것이다. 여기 accounts DB는 
솔라나는 Tower BFT라는 합의 알고리즘을 사용한다. 이는 전통적인 합의 알고리즘과는 다르게 POH를 사용하여 위에서 말했던 것처럼 트랜잭션의 순서를 미리 정해놓는다. 미리 정해놓기 때문에 트랜잭션의 순서를 파악하기 위해 노드 간 통신이 필요하지 않다. 그리고 이렇게 블록들이 전파되었을 때, 이더리움과 마찬가지로 블록의 유효성을 검증하는 투표를 하게 된다. 합의에 참여하려면 validator들은 유효한 블록에 대해 투표를 제출한다. 이것은 트랜잭션으로 처리되며, 일반 사용자 트랜잭션과 함께 블록에 포함된다. 이러한 이유로 solana 트랜잭션은 투표 트랜잭션과 비투표 트랜잭션으로 구분된다. 성공적인 투표를 제출하면, 크레딧을 얻게된다. 솔라나:poh로 이놈이 보낸 순서가 맞다는 그냥 믿음 +  순서가 보장되니 의존관계 없는거는 동시에 병렬로 돌려버린다음에  머클루트 확인 / 이더리움: 블록에 있는 순서 자체도 믿을 수 없으므로 하나씩 돌려본 다음에 머클루트 최종 확인.
솔라나에서는 새로 생성된 블록에 대해 모든 검증자가 합의할 때가지 기다리지 않고 다음 블록을 생성한다. (continous block generation) solana는 각 블록에 대해 bank를 사용하여 해당 블록의 상태를 참조한다. 
solana에서 tx의 상태는 합의과정에서 어떤 상태에 있는지에 따라 달라진다. processed는 처리된 상태, confirmed는 확인된 상태(2/3에 의해 투표, 트랜잭션이 포함된 블록이), 그리고 finalized(트랜잭션이 포함된 블록 위에 31개이상의 블록이 쌓임) 
confirmed된 블록이 finalized되지 않은 상태는 지금껏  없다. 